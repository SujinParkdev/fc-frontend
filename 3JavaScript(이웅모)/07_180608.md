## 복습 

### 변수 호이스팅 (Variable Hoisting)
- 모든 선언문은 호이스팅된다. 호이스팅이란 모든 선언문이 해당 Scope 선두로 옮겨진 것처럼 동작한다.
- 

기본자료형은 값, 타입이 일치하면 true
Object는 참조형데이터. 값으로 주소를 가지기 때문에 
```
var a = {}; 
var b = {}; 
a === b ///false
```

---
### 객체(Object)
프로퍼티의 집합. 프로퍼티는 property name, property value로 

---
Math.max.apply 그냥 외워라

---
## Scope

JavaScript는 Function-level Scope(if문 등 코드 블럭 내에서 선언되었다 해도 global scope)
그러나 ES6부터는 let으로 code-block scope 변수할당 가능하다!

- 함수 내의 지역 영역에서 전역변수와 지역변수가 모두 참조 가능하다. 만약 변수명이 중복된다면 지역변수를 우선한다(가까운 쪽을 먼저 찾는다). 올라가고 올라가고 전역까지 갔는데 없으면 reference error를 내는 것.

- 내부 함수는 자신을 포함하고 있는 외부함수의 변수에 접근 가능

```
var x = 10;

function foo() {
  x = 100;
  console.log(x);
}
foo();
console.log(x); // ?
```
함수 내부의 콘솔로그 하기 위해 x를 찾는데, 함수 안에 있는 x는 변수 선언이 아니라 재할당 하는 x다! 전역에 선언된 x = 10;을 재할당하는 코드. 그래서 최종적으로 출력되는 것은 100이다.

```
var foo = function ( ) {

  var a = 3, b = 5;

  var bar = function ( ) {
    var b = 7, c = 11;

// 이 시점에서 a는 3, b는 7, c는 11

    a += b + c;

// 이 시점에서 a는 21, b는 7, c는 11

  };

// 이 시점에서 a는 3, b는 5, c는 not defined

  bar( );

// 이 시점에서 a는 21, b는 5

};
```
---
### 암묵적 전역
```
function foo() {
  x = 1;   // Throws a ReferenceError in "use strict" mode
  var y = 2;
}

foo();

console.log(x); // 1
console.log(y); // ReferenceError: y is not defined
```
자바스크립트는 지역에서 x를 찾고, 전역에서 x를 찾아도 없으니 x를 만들었다.
**전역변수가 아에 없다고 생각하고 코딩하라** 이렇게 전역변수가 있는 줄 알고 재할당을 시도했는데 의도치 않게 전역변수를 만들 수도 있다.

---
### Lexical scoping(Static soping)

```
var i = 5;

function foo() {
  var i = 10;
  bar();
}

function bar() { // 선언된 시점에서의 scope를 갖는다!
  console.log(i);
}

foo(); // ?
```
선언된 시점의 환경을 보기 때문에 함수bar는 전역함수. 전역 변수 i를 찾기 때문에 5가 출력

---
### 변수명의 중복

JavaScript 파일을 여러개 만들어서 넣는다고 해도, 하나의 window객체에 적용된다.(메인 스페이스가 하나이다) 이 때 자바스크립트는 변수명의 중복을 허용하므로 다른 스크립트 파일에 넣었다고 해도 변수 명이 중복된다. 
-> ES6에서 module을 지원. 그러나 모든 브라우저에서 모듈이 전혀 지원되지 않고 있다.

**이와 같이 전역변수의 무분별한 사용은 무척 위험하다. 전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 범위인 스코프는 좁을수록 좋다.**

---
### 최소한의 전역변수 사용을 위한 IIFE(즉시실행함수)

즉시실행함수는 실행된 후 전역에서 바로 사라진다.

---
### 최소한의 전역변수 사용을 위해 

전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. (더글라스 크락포드의 제안) -> 그러나 올드한 방법 -> ES6에서 클래스를 사용!

---
## Javascript this

1. this는 전역객체를 가르킨다.
2. 두 가지 예외가 있다 
- 생성자 함수 내에서의 this는 생성자 함수가 생성한 객체를 가르킨다 .
- 메서드 내에서 사용한 this는 메서드를 호출한 객체를 가르킨다.

자바스크립트는 객체이기 때문에 프로퍼티가 있다. arguments가 있는데 함수 바디 내에서 지역변수처럼 사용했다. 이와 마찬가지로 this도 함수 내부에서 선언하지 않아도 생성되는 것처럼 보인다. this는 메서드도, 생성자 함수도 아니다. 전역객체. 

자바스크립트가 함수 내에서 this를 사용할 수 있도록 자동으로 끼워넣어준다.
자스가 함수에 this를 추가할 때 this가 뭘 가르키게 하느냐는 규칙에 따라 세팅해준다.(바인딩한다)

---
자바스크립트의 경우 함수 호출 패턴에 따라 어떤 객체를 this에 바인딩할지 결정된다

1. 함수 호출 패턴
웹환경에서 전역객체는 window
node.js(terminal)에서 전역 객체는 global

파일을 나눠도 전역객체는 하나다! 무슨 의미일까?
js를 돌려도 브라우저에서 동작한다.  모던한 브라우저는 탭이 있는데, 탭은 여러 브라우저를 묶어 놓은 것. 그래서 탭마다 window객체가 하나씩 있다.

전역변수는 application이 죽지않는한 계속 살아있는다. 그래서 전역변수 쓰지말고 함수를 작게 만들어 지역함수를 쓰고 소멸시켜라. 전역 객체면 window안에 있고, 모든 것들이 다 window안에 있기 때문에 굳이 window 쓸 필요가 없도록 만든다.

```
var value = 1;

var obj = {
  value: 100,
  foo: function() {
    console.log("foo's this: ",  this);  // obj
    console.log("foo's this.value: ",  this.value); // 100
    function bar() {
      console.log("bar's this: ",  this); // window(이 내부함수는 생성자함수 아님!)
      console.log("bar's this.value: ", this.value); // 1(window.value와 같음)
    }
    bar();
  }
};

obj.foo();
```
obj는 주소값을 가지고 있다. value : 100; 값 자체를 가지고 있고 메서드 foo는 주소값을 가지고, 실제로는 또 다른 영역에 있는 것. 

```
var value = 1;

var obj = {
  value: 100,
  foo: function() { //foo는 메서드이기 때문에 foo의 this는 obj를 가리킴
    setTimeout(function() { //그냥 함수이기 때문에 setTimeout의 this는 window.
      console.log("callback's this: ",  this);  // window
      console.log("callback's this.value: ",  this.value); // 1
    }, 100);
  }
};

obj.foo();
```

---
### 해결하는 방법
```
var value = 1;

var obj = {
  value: 100,
  foo: function() {
    var that = this;  // Workaround : this === obj 참조를 할당.(참조를 대피시킨 것)

    console.log("foo's this: ",  this);  // obj
    console.log("foo's this.value: ",  this.value); // 100
    function bar() {
      console.log("bar's this: ",  this); // window 내부함수라서 this는 window.
      console.log("bar's this.value: ", this.value); // 1

      console.log("bar's that: ",  that); // obj
      console.log("bar's that.value: ", that.value); // 100
    }
    bar();
  }
};

obj.foo();
```

---
### this를 왜 사용할까?

객체는 데이너터와 데이터를 관리할 수 있는 메서드로 이루어져있다. 메서드는 데이터들을 관리하는 것.

생성자함수로 객체를 생성할 때 아직 객체의 이름을 모름. 그럴 때 자신이 소속된 객체의 프로퍼티를 가리키기 위해서 this를 사용.
```
var obj1 = {
  name: 'Lee',
  sayName: function() {
    console.log(this.name);
  }
}

var obj2 = {
  name: 'Kim'
}

obj2.sayName = obj1.sayName;

obj1.sayName();
obj2.sayName();
```
this가 있기 때문에 obj2.sayName = obj1.sayName;가 가능한 것.

```
function Person(name) {
  this.name = name; //this는 미래에 생성할 객체를 가리킴.
}

Person.prototype.getName = function() {
  return this.name; //메서드 내부에 있는 this. 그래서 메서드를 호출한 객체를 가르킴.
}

var me = new Person('Lee');
console.log(me.getName());

Person.prototype.name = 'Kim';
console.log(Person.prototype.getName());
```