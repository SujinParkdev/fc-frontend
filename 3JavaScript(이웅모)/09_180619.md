## JavaScript DOM

## 문서 객체 모델(Document Object Model)

브라우저는 웹문서(HTML, SML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다. 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하기 위해서 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다. 

모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고, 이들 객체를 부자 관계로 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. 이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌덜이에 반영된다. 

HTML과 CSS는 tag, attribute 등을 미리 정해 놓은 뒤 요소를 배치하는 언어. HTML은 중첩관계는 대체로 부자관계를 갖는다. CSS는 캐스캐이딩, 상속으로 이뤄져있다.

이 요소들을 객체화해서 만든 것이 DOM.

---
DOM을 공부하는 방법 : 개념적인 것보다 결국 API를 어떻게 쓰느냐가 중요하다. 많이 쳐봐서 외워질 정도로 해야한다.

예를 들어 강사님 웹페이지에 접속하기 위해
검색창에 주소를 입력하고 엔터를 누른다.

브라우저가 서버에게 웹페이지를 요청한다. 서버는 요청에 응답한다. 

브라우저마다 방식이 다르다(web-kit계열 : chrome, gekko계열 : firefox)
클라이언트 : HTML를 파싱하다 CSS 삽입 태그를 만나면 파싱을 멈추고 request
서버 : CSS파일을 아스키코드의 문자열의 형태로 넘겨줌
클라이언트 : 아스키코드를 파일로 묶음(Create CSSOM tree)
CSS
JavaScript

크롬에서는 DOM tree를 만든다.

자바스크립트 APISMS HTML/CSS를 제어한다. 돔트리와 씨솜트리를 조작하는 것. 조작한 결과를 가지고 다시 렌더트리를 만들고 그것을 Display하는 것.

세가지를 따로 받는 방식이 HTTP1.1방식
HTTP는 2.0 세가지를 같이 받는 방식

지금 우리 쓰는 방법 방식은 HTTP1.1

우리가 자바스크립트의 요소를 삭제하고 할 때는, 요소에 접근하여 클래스

---
오후

---
## 4.3 HTML 콘텐츠 조작(Manipulation)

스크립트 태그도 요소노드. 스크립트 태그를 추가하는 순간 즉시 실행되는 특징을 가지고 있다. 위험할 수 있다. 만약 악성코드가 들어가 있는 스크립트라면, 삽입하는 즉시 악성코드가 실행되어 해킹될 위험이 있음. 마크업이 포함된 콘텐츠를 추가하는 행위는 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하므로 주의가 필요하다.

- textContent : 콘텐츠를 텍스트로 받아온다. 요소 내부에 있는 모든 내용을 텍스트로 반환한다. ul.textContent라고 하면 요소 사이의 공백, 줄바꿈 문자를 모두 텍스트 노드로 취급하기 때문에 사용하기가 불편하다. 만약 요소의 마크업이 포함된 콘텐츠라면(예를 들어 안에 태그가 삽입되어 있다면) 모조리 문자열로 반환.

- innerText : 비표준. 사용권장하지 않음.

- innerHTML : 이 친구를 사용하자. 해당 요소의 모든 자식 요소를 포함하는 모든 콘첸츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다!!!

```
elem.innerHTML = '<img src="#" onerror="alert(\'XSS\')">';
```
에러 이벤트를 발생시켜 스크립트가 실행되도록 한다. 로그인 기능이 있으면 위험함. innerHTML을 할당할 때는 저 문자열 부분을 바꿔치지하는 것. 

---
## 4.4 DOM 조작 방식

- createElement(tagName)
태그이름을 인자로 전달하여 요소를 생성한다.
Return: HTMLElement를 상속받은 객체
모든 브라우저에서 동작한다.
- createTextNode(text)
텍스트를 인자로 전달하여 텍스트 노드를 생성한다.
Return: Text 객체
모든 브라우저에서 동작한다.
- appendChild(Node)
인자로 전달한 노드를 자식 요소로 DOM 트리에 추가한다.
Return: 추가한 노드
모든 브라우저에서 동작한다.
- removeChild(Node)
인자로 전달한 노드를 DOM 트리에 제거한다.
Return: 추가한 노드
모든 브라우저에서 동작한다.

innerHTML보다 불편하나 해킹에는 보다 안전.

---
## 4.5 insertAdjacentHTML()

- insertAdjacentHTML(position, string)
인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다. 첫번째 인자는 삽입 위치, 두번째 인자는 삽입할 요소를 표현한 문자열이다. 첫번째 인자로 올 수 있는 값은 아래와 같다.
‘beforebegin’
‘afterbegin’
‘beforeend’
‘afterend’
모든 브라우저에서 동작한다.

appendChild를 사용하면 beforeend자리에 추가가 되나, insertAdjacentHTML을 사용하면 더 세밀하게 추가할 수 있다.

---
다 고만고만하다. 보통 이렇게 사용할 때는 내부에서 테스트용으로 가볍게 쓸 때 이렇게 만든다. 그럴 때는 그냥 innerHTML을 사용해라. 그리고 유저 인풋을 받을 때는 그 안에 스크립트가 있는지 확인하고, 있으면 날려버리도록 조작해야 한다.

---
## 5. style

style 프로퍼티의 값을 취득하려면 window.getComputedStyle을 사용한다. 
왜?? computed? 
스타일은 적용한다고 해서 반드시 내가 지정한 스타일이 적용되는 것이 아니다. 다른 곳에서 영향을 받을 수 있기 때문에 컴퓨티드, 합쳐진 스타일을 알아내는 것

강사님 추천! 정리 잘되어 있다.
https://quirksmode.org/dom/core/

---
## 동기식 처리 모델 vs 비동기식 처리 모델

## 동기식 처리 모델(Synchronous processing model)

동기식 처리 모델(Synchronous processing model)은 직렬적으로 태스크(task)를 수행한다. 즉, 태스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다.

예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹(blocking, 작업 중단)된다. 블로킹타임에는 브라우저가 멈춰있는 것처럼 보인다.

장점 : 코딩이 쉽고, 예측하기 쉽다.
단점 : 블로킹이 발생한다. 화면이 freeze가 됨. UX관점에서 0점!

---
## 비동기식 처리 모델

순차적으로 진행되지 않는다. 서버에 데이터를 요청하고 결과를 기다리지 않고 바로 다음일을 한다. 브라우저가 동시에 일을 하는 것처럼 보인다. 

setTimeout이 비동기 함수. 두번째 인자가 기다리는 시간. 그런데 0으로 세팅해놨으니 바로 시작함.

---
## 사용자와 웹페이지의 상호작용을 위한 이벤트

이벤트는 언제 사용자가 만질지 모른다. 그럼 어떻게 코딩해야할까?
사용자가 클릭할 때, 요청을 보내도록 함수를 만들어 놓는 것.
함수의 호출을 우리가 명시적으로 호출하는 것이 아니라 사용자가 클릭하면 함수가 호출되도록 만들어야 한다.

---
## 이벤트 루프와 동시성
